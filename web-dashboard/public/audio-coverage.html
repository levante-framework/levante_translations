<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Audio Coverage Report</title>
  <link rel="stylesheet" href="./styles.css" />
    <link rel="icon" type="image/svg+xml" href="./audio-favicon.svg" />
  <script src="./config.js"></script>
  <style>
    .coverage-container{padding:20px}
    .grid-table{width:100%; border-collapse:collapse}
    .grid-table th,.grid-table td{border:1px solid #e0e0e0; padding:8px; text-align:left}
    .chip{display:inline-block; padding:4px 8px; border-radius:12px; font-size:12px; margin-right:6px}
    .chip.ok{background:#e6f4ea; color:#1e7e34}
    .chip.missing{background:#fdecea; color:#842029}
  </style>
</head>
<body>
  <div class="coverage-container">
    <h2><i class="fas fa-table"></i> Audio Coverage by Language and Voice</h2>
    <p>This report counts generated audio files per language and per embedded voice (ID3 tag).</p>
    <div id="summary"></div>
    <table class="grid-table" id="coverageTable">
      <thead>
        <tr>
          <th>Language</th>
          <th>Voice</th>
          <th>Count</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/all.min.js"></script>
  <script>
    async function fetchJson(url, init){ const r = await fetch(url, init); if(!r.ok) throw new Error(await r.text()); return r.json(); }

    function robustParseCSV(text){
      const rows = [];
      let current = [];
      let field = '';
      let inQuotes = false;
      for(let i=0;i<text.length;i++){
        const ch = text[i];
        const next = i+1<text.length ? text[i+1] : '';
        if(ch === '"'){
          if(inQuotes && next === '"'){ field+='"'; i++; }
          else { inQuotes = !inQuotes; }
        } else if(ch === ',' && !inQuotes){ current.push(field); field=''; }
        else if((ch==='\n' || ch==='\r') && !inQuotes){
          if(ch==='\r' && next==='\n'){ i++; }
          current.push(field); field='';
          if(current.some(v=>v && v.trim().length>0)) rows.push(current);
          current = [];
        } else { field += ch; }
      }
      if(field.length>0 || current.length>0){ current.push(field); if(current.some(v=>v && v.trim().length>0)) rows.push(current); }
      return rows;
    }

    let cachedIds = null;
    async function getAllItemIds(){
      if(cachedIds) return cachedIds;
      const csvUrl = (window.CONFIG && window.CONFIG.dataSources && window.CONFIG.dataSources.remoteCSV) 
        ? window.CONFIG.dataSources.remoteCSV 
        : 'https://raw.githubusercontent.com/levante-framework/levante_translations/l10n_pending/item-bank-translations.csv';
      const txt = await (await fetch(csvUrl)).text();
      const rows = robustParseCSV(txt);
      if(rows.length===0) return [];
      const header = rows[0].map(h=>h.trim());
      const idKeyIdx = (()=>{ const i1=header.indexOf('item_id'); const i2=header.indexOf('identifier'); return i1>=0?i1:i2; })();
      const ids = new Set();
      for(let i=1;i<rows.length;i++){
        const r = rows[i];
        const val = (r[idKeyIdx]||'').toString().replace(/\r/g,'').trim();
        if(val) ids.add(val);
      }
      cachedIds = Array.from(ids);
      return cachedIds;
    }

    async function listAudio(language){
      const ids = await getAllItemIds();
      return ids.map(id => ({ lang: language, id, url: `https://storage.googleapis.com/levante-audio-dev/${language}/${id}.mp3` }));
    }

    async function readTag(item){
      try{
        const res = await fetchJson(`/api/read-tags?itemId=${encodeURIComponent(item.id)}&langCode=${encodeURIComponent(item.lang)}&strict=1`);
        return { ok: true, lang: item.lang, id: item.id, voice: (res.id3Tags && res.id3Tags.voice) || 'Not available' };
      }catch(e){
        return { ok: false, lang: item.lang, id: item.id, err: e.message };
      }
    }

    function groupCounts(records){
      const map = new Map();
      for(const r of records){
        if(!r.ok) continue;
        const key = `${r.lang}||${r.voice}`;
        map.set(key, (map.get(key)||0)+1);
      }
      return Array.from(map.entries()).map(([k,v])=>{ const [lang,voice]=k.split('||'); return {lang,voice,count:v}; });
    }

    async function build(){
      // Base languages from config
      const languages = (window.CONFIG && window.CONFIG.languages) ? window.CONFIG.languages : {};
      const configCodes = Array.from(new Set(Object.values(languages).map(l=>l.lang_code))).filter(Boolean);

      // Also query the audio bucket to include any languages that exist there
      let bucketCodes = [];
      try {
        const listed = await fetchJson('/api/read-tags?list=1');
        bucketCodes = Array.isArray(listed.languages) ? listed.languages : [];
      } catch (e) {
        console.warn('Failed to list audio languages from bucket:', e.message);
      }

      const langCodes = Array.from(new Set([...(configCodes||[]), ...(bucketCodes||[])]));
      if (langCodes.length === 0) {
        langCodes.push('en','es-CO','de','fr-CA','nl');
      }

      const ids = await getAllItemIds();
      const allItems = [];
      for(const code of langCodes){
        for(const id of ids){
          allItems.push({ lang: code, id, url: `https://storage.googleapis.com/levante-audio-dev/${code}/${id}.mp3` });
        }
      }

      const total = allItems.length;
      let processed = 0;
      const updateSummary = (okCount, errCount, noTagCount = 0) => {
        document.getElementById('summary').innerHTML =
          `<span class="chip ok">Languages: ${langCodes.length}</span>`+
          `<span class="chip ok">Progress: ${processed}/${total}</span>`+
          `<span class="chip ok">Files scanned: ${okCount}</span>`+
          `<span class="chip missing">Missing/Errors: ${errCount}</span>`+
          `<span class="chip missing">No-tag files: ${noTagCount}</span>`;
      };

      // Bounded concurrency to avoid overwhelming serverless/API
      async function processWithConcurrency(items, limit = 12){
        const results = new Array(items.length);
        let next = 0, okCount = 0, errCount = 0;
        async function worker(){
          while(true){
            const i = next++;
            if(i >= items.length) break;
            try{
              const r = await readTag(items[i]);
              results[i] = r;
              if(r && r.ok) okCount++; else errCount++;
            }catch(e){
              results[i] = { ok:false, err: String(e) };
              errCount++;
            }finally{
              processed++;
              if(processed % 50 === 0 || processed === total){ updateSummary(okCount, errCount); }
            }
          }
        }
        const workers = Array.from({length: Math.min(limit, items.length)}, ()=>worker());
        await Promise.all(workers);
        updateSummary(okCount, errCount);
        return results;
      }

      updateSummary(0, 0);
      const results = await processWithConcurrency(allItems, 12);
      const grouped = groupCounts(results);

      // Count files that exist but have no ID3 voice tag
      const noTagCount = results.reduce((acc, r) => acc + (r && r.ok && (!r.voice || r.voice === 'Not available') ? 1 : 0), 0);
      updateSummary(results.filter(r=>r && r.ok).length, results.filter(r=>!r || !r.ok).length, noTagCount);

      // Ensure every language listed in summary appears in the detail table.
      // If a language has 0 found files, add a placeholder row with any info we have (missing/errors count).
      const presentLangs = new Set(grouped.map(r => r.lang));
      if (langCodes && Array.isArray(langCodes)) {
        for (const code of langCodes) {
          if (!presentLangs.has(code)) {
            const errsForLang = results.reduce((acc, r) => acc + ((r && r.lang === code && !r.ok) ? 1 : 0), 0);
            grouped.push({ lang: code, voice: `No files (missing/errors: ${errsForLang})`, count: 0 });
          }
        }
      }

      const tbody = document.querySelector('#coverageTable tbody');
      tbody.innerHTML = '';
      // Split rows into those with files (count>0) and those without (placeholders)
      const withFiles = grouped.filter(r => r.count > 0);
      const noFiles = grouped.filter(r => r.count === 0);

      withFiles.sort((a,b)=>{
        const byLang = a.lang.localeCompare(b.lang);
        if (byLang !== 0) return byLang;
        const aIsNA = a.voice === 'Not available';
        const bIsNA = b.voice === 'Not available';
        if (aIsNA !== bIsNA) return aIsNA ? 1 : -1; // push "Not available" to bottom within language
        const byCount = b.count - a.count;
        if (byCount !== 0) return byCount;
        return a.voice.localeCompare(b.voice);
      }).forEach(row=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${row.lang}</td><td>${row.voice}</td><td>${row.count}</td>`;
        tbody.appendChild(tr);
      });

      if (noFiles.length) {
        // Separator row
        const sep = document.createElement('tr');
        sep.innerHTML = `<td colspan="3" style="background:#f7f7f7; color:#666; font-weight:bold; text-align:center;">Languages with no files</td>`;
        tbody.appendChild(sep);

        // Sort no-files languages alphabetically
        noFiles.sort((a,b) => a.lang.localeCompare(b.lang)).forEach(row => {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${row.lang}</td><td>${row.voice}</td><td>${row.count}</td>`;
          tbody.appendChild(tr);
        });
      }
    }

    build().catch(e=>{ console.error(e); alert('Failed to build coverage: '+e.message); });
  </script>
</body>
</html>

