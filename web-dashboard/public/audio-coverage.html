<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Audio Coverage Report</title>
  <link rel="stylesheet" href="./styles.css" />
    <link rel="icon" type="image/svg+xml" href="./audio-favicon.svg" />
  <script src="./config.js"></script>
  <style>
    .coverage-container{padding:20px}
    .grid-table{width:100%; border-collapse:collapse}
    .grid-table th,.grid-table td{border:1px solid #e0e0e0; padding:8px; text-align:left}
    .chip{display:inline-block; padding:4px 8px; border-radius:12px; font-size:12px; margin-right:6px}
    .chip.ok{background:#e6f4ea; color:#1e7e34}
    .chip.missing{background:#fdecea; color:#842029}
  </style>
</head>
<body>
  <div class="coverage-container">
    <h2><i class="fas fa-table"></i> Audio Coverage by Language and Voice</h2>
    <p>This report counts generated audio files per language and per embedded voice (ID3 tag).</p>
    <div class="source-row">
      <div class="source-card">
        <div class="source-title">Source</div>
        <div class="source-controls">
          <button class="pill" id="useRepo">Repo</button>
          <button class="pill" id="useDev">Dev</button>
          <button class="pill" id="useProd">Prod</button>
          <button class="pill rescan-btn" id="rescanBtn">ðŸ”„ Rescan</button>
        </div>
        <div class="source-detail">
          <label for="bucketInput">Bucket</label>
          <input id="bucketInput" type="text" value="levante-assets-dev" placeholder="levante-assets-dev" />
          <span class="hint">audio URLs: <code>gs://&lt;bucket&gt;/audio/&lt;lang&gt;/&lt;id&gt;.mp3</code></span>
        </div>
      </div>
    </div>
    <div id="summary"></div>
    <table class="grid-table" id="coverageTable">
      <thead>
        <tr>
          <th>Language</th>
          <th>Voice</th>
          <th>Count</th>
          <th>Missing</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/js/all.min.js"></script>
  <script>
    // Styles for nicer source row
    const style = document.createElement('style');
    style.textContent = `
      .source-row{margin:12px 0 18px 0}
      .source-card{border:1px solid #e5e7eb; border-radius:10px; padding:10px 12px; background:#fafafa}
      .source-title{font-weight:600; color:#374151; margin-bottom:6px}
      .source-controls{display:flex; gap:6px; margin-bottom:8px}
      .pill{border-radius:999px; border:1px solid #d1d5db; padding:4px 10px; background:#fff; cursor:pointer}
      .pill:hover{background:#f3f4f6}
      .pill.active{background:#111827; color:#fff; border-color:#111827}
      .rescan-btn{background:#2563eb !important; color:#fff !important; border-color:#2563eb !important}
      .rescan-btn:hover{background:#1d4ed8 !important}
      .source-detail{display:flex; align-items:center; gap:8px}
      #bucketInput{width:280px; padding:6px 8px; border:1px solid #d1d5db; border-radius:6px}
      #bucketInput:disabled{background:#f3f4f6; color:#6b7280; cursor:not-allowed}
      .hint{color:#6b7280; font-size:12px}
    `;
    document.head.appendChild(style);
    // Bucket selection helpers
    let currentSource = 'bucket'; // 'bucket' or 'repo'

    function getSelectedBucket(){
      const el = document.getElementById('bucketInput');
      const val = (el && el.value || '').trim();
      return val || 'levante-assets-dev';
    }
    function rememberBucket(val){ try{ localStorage.setItem('levante_audio_bucket', val); }catch(_){} }
    function rememberSource(val){ try{ localStorage.setItem('levante_audio_source', val); }catch(_){} }
    function updateSourceUI(){
      const repoBtn = document.getElementById('useRepo');
      const devBtn = document.getElementById('useDev');
      const prodBtn = document.getElementById('useProd');
      [repoBtn, devBtn, prodBtn].forEach(btn => { if(btn){ btn.classList.remove('active'); }});
      const activeBtn = currentSource === 'repo' ? repoBtn : (document.getElementById('bucketInput').value.includes('-prod') ? prodBtn : devBtn);
      if(activeBtn) activeBtn.classList.add('active');
      const labelEl = document.querySelector('.source-detail label');
      const inputEl = document.getElementById('bucketInput');
      const hintEl = document.querySelector('.source-detail .hint');
      if(currentSource === 'repo'){
        if(labelEl) labelEl.textContent = 'Repository';
        if(inputEl){ inputEl.disabled = true; inputEl.placeholder = 'levante-framework/levante_translations (audio_files/*)'; }
        if(hintEl) hintEl.innerHTML = 'audio URLs: <code>https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files/&lt;lang&gt;/&lt;id&gt;.mp3</code>';
      } else {
        if(labelEl) labelEl.textContent = 'Bucket';
        if(inputEl){ inputEl.disabled = false; if(!inputEl.value) inputEl.value = 'levante-assets-dev'; }
        if(hintEl) hintEl.innerHTML = 'audio URLs: <code>gs://&lt;bucket&gt;/audio/&lt;lang&gt;/&lt;id&gt;.mp3</code>';
      }
    }
    function restoreSelectors(){
      try{
        const saved = localStorage.getItem('levante_audio_bucket');
        if(saved){ document.getElementById('bucketInput').value = saved; }
        const s = localStorage.getItem('levante_audio_source');
        if(s){ currentSource = s; }
      }catch(_){}
    }
    (function initBucketUI(){
      restoreSelectors();
      const repoBtn = document.getElementById('useRepo');
      const devBtn = document.getElementById('useDev');
      const prodBtn = document.getElementById('useProd');
      const rescanBtn = document.getElementById('rescanBtn');
      if(repoBtn){ repoBtn.addEventListener('click', ()=>{ currentSource='repo'; rememberSource('repo'); updateSourceUI(); }); }
      if(devBtn){ devBtn.addEventListener('click', ()=>{ currentSource='bucket'; document.getElementById('bucketInput').value='levante-assets-dev'; rememberBucket('levante-assets-dev'); rememberSource('bucket'); updateSourceUI(); }); }
      if(prodBtn){ prodBtn.addEventListener('click', ()=>{ currentSource='bucket'; document.getElementById('bucketInput').value='levante-assets-prod'; rememberBucket('levante-assets-prod'); rememberSource('bucket'); updateSourceUI(); }); }
      if(rescanBtn){ rescanBtn.addEventListener('click', ()=>{ 
        // Clear caches and restart
        cachedCsvLangCodes = null; 
        cachedIds = null; 
        document.getElementById('summary').innerHTML = '<span class="chip">Rescanning...</span>';
        document.querySelector('#coverageTable tbody').innerHTML = '';
        build().catch(e=>{ console.error(e); alert('Rescan failed: '+e.message); });
      }); }
      const input = document.getElementById('bucketInput');
      if(input){ input.addEventListener('change', ()=> { rememberBucket(getSelectedBucket()); rememberSource('bucket'); currentSource='bucket'; updateSourceUI(); }); }
      updateSourceUI();
    })();

    // Global abort controller to cancel in-flight requests when navigating away
    const globalAbortController = new AbortController();
    window.addEventListener('beforeunload', () => {
      try { globalAbortController.abort(); } catch (e) {}
    });

    async function fetchJson(url, init){
      try{
        const options = init ? { ...init } : {};
        if (!options.signal) options.signal = globalAbortController.signal;
        const r = await fetch(url, options);
        if(!r.ok) throw new Error(await r.text());
        return r.json();
      }catch(err){
        // Normalize aborted fetch errors
        if (err && (err.name === 'AbortError' || String(err).toLowerCase().includes('aborted'))) {
          throw new Error('aborted');
        }
        throw err;
      }
    }

    function robustParseCSV(text){
      const rows = [];
      let current = [];
      let field = '';
      let inQuotes = false;
      for(let i=0;i<text.length;i++){
        const ch = text[i];
        const next = i+1<text.length ? text[i+1] : '';
        if(ch === '"'){
          if(inQuotes && next === '"'){ field+='"'; i++; }
          else { inQuotes = !inQuotes; }
        } else if(ch === ',' && !inQuotes){ current.push(field); field=''; }
        else if((ch==='\n' || ch==='\r') && !inQuotes){
          if(ch==='\r' && next==='\n'){ i++; }
          current.push(field); field='';
          if(current.some(v=>v && v.trim().length>0)) rows.push(current);
          current = [];
        } else { field += ch; }
      }
      if(field.length>0 || current.length>0){ current.push(field); if(current.some(v=>v && v.trim().length>0)) rows.push(current); }
      return rows;
    }

    // Extract language codes from the CSV header
    let cachedCsvLangCodes = null;
    async function getCsvLanguageCodes(){
      if(cachedCsvLangCodes) return cachedCsvLangCodes;
      const csvUrl = (window.CONFIG && window.CONFIG.dataSources && window.CONFIG.dataSources.remoteCSV) 
        ? window.CONFIG.dataSources.remoteCSV 
        : 'https://raw.githubusercontent.com/levante-framework/levante_translations/l10n_pending/item-bank-translations.csv';
      const txt = await (await fetch(csvUrl)).text();
      const rows = robustParseCSV(txt);
      if(rows.length===0) return [];
      const header = rows[0].map(h=> (h||'').toString().trim());
      const exclude = new Set(['item_id','identifier','labels','context','source','source_phrase','translation','task','task_name','notes']);
      const langRegex = /^[A-Za-z]{2,3}(?:-[A-Za-z0-9]{2,8})*$/;
      const codes = [];
      for(const h of header){
        const lower = h.toLowerCase();
        if(exclude.has(lower)) continue;
        if(h === 'en' || langRegex.test(h)) codes.push(h);
      }
      cachedCsvLangCodes = Array.from(new Set(codes));
      return cachedCsvLangCodes;
    }

    let cachedIds = null;
    async function getAllItemIds(){
      if(cachedIds) return cachedIds;
      const csvUrl = (window.CONFIG && window.CONFIG.dataSources && window.CONFIG.dataSources.remoteCSV) 
        ? window.CONFIG.dataSources.remoteCSV 
        : 'https://raw.githubusercontent.com/levante-framework/levante_translations/l10n_pending/item-bank-translations.csv';
      const txt = await (await fetch(csvUrl)).text();
      const rows = robustParseCSV(txt);
      if(rows.length===0) return [];
      const header = rows[0].map(h=>h.trim());
      const idKeyIdx = (()=>{ const i1=header.indexOf('item_id'); const i2=header.indexOf('identifier'); return i1>=0?i1:i2; })();
      const ids = new Set();
      for(let i=1;i<rows.length;i++){
        const r = rows[i];
        const val = (r[idKeyIdx]||'').toString().replace(/\r/g,'').trim();
        if(val) ids.add(val);
      }
      cachedIds = Array.from(ids);
      return cachedIds;
    }

    async function listAudio(language){
      const ids = await getAllItemIds();
      if(currentSource === 'repo'){
        return ids.map(id => ({ lang: language, id, url: `https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files/${encodeURIComponent(language)}/${encodeURIComponent(id)}.mp3` }));
      }
      const bucket = getSelectedBucket();
      return ids.map(id => ({ lang: language, id, url: `https://storage.googleapis.com/${encodeURIComponent(bucket)}/audio/${encodeURIComponent(language)}/${encodeURIComponent(id)}.mp3` }));
    }

    async function readTag(item){
      try{
        const params = new URLSearchParams();
        params.set('itemId', item.id);
        params.set('langCode', item.lang);
        params.set('strict', '1');
        if(currentSource === 'repo'){
          params.set('source', 'repo');
        } else {
          params.set('bucket', getSelectedBucket());
        }
        const res = await fetchJson(`/api/read-tags?${params.toString()}`);
        return { ok: true, lang: item.lang, id: item.id, voice: (res.id3Tags && res.id3Tags.voice) || 'Not available' };
      }catch(e){
        return { ok: false, lang: item.lang, id: item.id, err: e.message };
      }
    }

    function groupCounts(records){
      const map = new Map();
      for(const r of records){
        if(!r.ok) continue;
        const key = `${r.lang}||${r.voice}`;
        map.set(key, (map.get(key)||0)+1);
      }
      return Array.from(map.entries()).map(([k,v])=>{ const [lang,voice]=k.split('||'); return {lang,voice,count:v}; });
    }

    async function build(){
      // Base languages from config
      const languages = (window.CONFIG && window.CONFIG.languages) ? window.CONFIG.languages : {};
      const configCodes = Array.from(new Set(Object.values(languages).map(l=>l.lang_code))).filter(Boolean);

      // Also query the audio bucket to include any languages that exist there
      let bucketCodes = [];
      try {
        const params = new URLSearchParams();
        params.set('list','1');
        if(currentSource === 'repo'){
          params.set('source','repo');
        } else {
          params.set('bucket', getSelectedBucket());
        }
        const listed = await fetchJson(`/api/read-tags?${params.toString()}`);
        bucketCodes = Array.isArray(listed.languages) ? listed.languages : [];
      } catch (e) {
        console.warn('Failed to list audio languages from bucket:', e.message);
      }

      // Include languages found in the CSV header (e.g., en-GH, es-AR)
      let csvCodes = [];
      try {
        csvCodes = await getCsvLanguageCodes();
      } catch (e) {
        console.warn('Failed to parse languages from CSV:', e.message);
      }

      const langCodes = Array.from(new Set([...(configCodes||[]), ...(bucketCodes||[]), ...(csvCodes||[])]));
      if (langCodes.length === 0) {
        langCodes.push('en','es-CO','de','fr-CA','nl');
      }

      const ids = await getAllItemIds();
      const allItems = [];
      if(currentSource === 'repo'){
        for(const code of langCodes){
          for(const id of ids){
            allItems.push({ lang: code, id, url: `https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files/${encodeURIComponent(code)}/${encodeURIComponent(id)}.mp3` });
          }
        }
      } else {
        const bucket = getSelectedBucket();
        for(const code of langCodes){
          for(const id of ids){
            allItems.push({ lang: code, id, url: `https://storage.googleapis.com/${encodeURIComponent(bucket)}/audio/${encodeURIComponent(code)}/${encodeURIComponent(id)}.mp3` });
          }
        }
      }

      const total = allItems.length;
      let processed = 0;
      const updateSummary = (okCount, errCount, noTagCount = 0) => {
        document.getElementById('summary').innerHTML =
          `<span class="chip ok">Languages: ${langCodes.length}</span>`+
          `<span class="chip ok">Progress: ${processed}/${total}</span>`+
          `<span class="chip ok">Files scanned: ${okCount}</span>`+
          `<span class="chip missing">Missing/Errors: ${errCount}</span>`+
          `<span class="chip missing">No-tag files: ${noTagCount}</span>`;
      };

      // Bounded concurrency to avoid overwhelming serverless/API
      async function processWithConcurrency(items, limit = 8){
        const results = new Array(items.length);
        let next = 0, okCount = 0, errCount = 0;
        async function worker(){
          while(true){
            const i = next++;
            if(i >= items.length) break;
            try{
              const r = await readTag(items[i]);
              results[i] = r;
              if(r && r.ok) okCount++; else errCount++;
            }catch(e){
              // Swallow aborted errors quietly
              const msg = String(e || '');
              if (msg.toLowerCase().includes('aborted')) {
                results[i] = { ok:false, err: 'aborted' };
              } else {
                results[i] = { ok:false, err: msg };
              }
              errCount++;
            }finally{
              processed++;
              if(processed % 50 === 0 || processed === total){ updateSummary(okCount, errCount); }
            }
          }
        }
        const workers = Array.from({length: Math.min(limit, items.length)}, ()=>worker());
        await Promise.all(workers);
        updateSummary(okCount, errCount);
        return results;
      }

      updateSummary(0, 0);
      const results = await processWithConcurrency(allItems, 12);
      const grouped = groupCounts(results);

      // Count files that exist but have no ID3 voice tag
      const noTagCount = results.reduce((acc, r) => acc + (r && r.ok && (!r.voice || r.voice === 'Not available') ? 1 : 0), 0);
      updateSummary(results.filter(r=>r && r.ok).length, results.filter(r=>!r || !r.ok).length, noTagCount);

      // Ensure every language listed in summary appears in the detail table.
      // If a language has 0 found files, add a placeholder row with any info we have (missing/errors count).
      const presentLangs = new Set(grouped.map(r => r.lang));
      if (langCodes && Array.isArray(langCodes)) {
        for (const code of langCodes) {
          if (!presentLangs.has(code)) {
            const errsForLang = results.reduce((acc, r) => acc + ((r && r.lang === code && !r.ok) ? 1 : 0), 0);
            grouped.push({ lang: code, voice: `No files (missing/errors: ${errsForLang})`, count: 0 });
          }
        }
      }

      // Compute per-language missing counts relative to the set of IDs that have audio in any language
      const idsWithAnyAudio = new Set(results.filter(r => r && r.ok).map(r => r.id));
      const totalAny = idsWithAnyAudio.size;
      const okPerLang = new Map();
      for (const r of results) {
        if (r && r.ok) {
          okPerLang.set(r.lang, (okPerLang.get(r.lang) || 0) + 1);
        }
      }
      const missingPerLang = new Map();
      for (const code of langCodes) {
        const okCount = okPerLang.get(code) || 0;
        missingPerLang.set(code, Math.max(0, totalAny - okCount));
      }

      const tbody = document.querySelector('#coverageTable tbody');
      tbody.innerHTML = '';
      // Split rows into those with files (count>0) and those without (placeholders)
      const withFiles = grouped.filter(r => r.count > 0);
      const noFiles = grouped.filter(r => r.count === 0);

      withFiles.sort((a,b)=>{
        const byLang = a.lang.localeCompare(b.lang);
        if (byLang !== 0) return byLang;
        const aIsNA = a.voice === 'Not available';
        const bIsNA = b.voice === 'Not available';
        if (aIsNA !== bIsNA) return aIsNA ? 1 : -1; // push "Not available" to bottom within language
        const byCount = b.count - a.count;
        if (byCount !== 0) return byCount;
        return a.voice.localeCompare(b.voice);
      }).forEach(row=>{
        const tr = document.createElement('tr');
        tr.innerHTML = `<td>${row.lang}</td><td>${row.voice}</td><td>${row.count}</td><td>${missingPerLang.get(row.lang) ?? ''}</td>`;
        tbody.appendChild(tr);
      });

      if (noFiles.length) {
        // Separator row
        const sep = document.createElement('tr');
        sep.innerHTML = `<td colspan="4" style="background:#f7f7f7; color:#666; font-weight:bold; text-align:center;">Languages with no files</td>`;
        tbody.appendChild(sep);

        // Sort no-files languages alphabetically
        noFiles.sort((a,b) => a.lang.localeCompare(b.lang)).forEach(row => {
          const tr = document.createElement('tr');
          tr.innerHTML = `<td>${row.lang}</td><td>${row.voice}</td><td>${row.count}</td><td>${missingPerLang.get(row.lang) ?? ''}</td>`;
          tbody.appendChild(tr);
        });
      }
    }

    // Add debug logging for the first few items to see what IDs we're checking
    window.debugCoverage = async function() {
      const ids = await getAllItemIds();
      console.log('Sample item IDs from CSV:', ids.slice(0, 10));
      console.log('Total item IDs:', ids.length);
      const bucket = getSelectedBucket();
      console.log('Current bucket:', bucket);
      console.log('Current source:', currentSource);
      // Test a few specific files
      const testLang = 'de';
      const testIds = ids.slice(0, 3);
      for(const id of testIds) {
        const url = currentSource === 'repo' 
          ? `https://raw.githubusercontent.com/levante-framework/levante_translations/main/audio_files/${testLang}/${id}.mp3`
          : `https://storage.googleapis.com/${bucket}/audio/${testLang}/${id}.mp3`;
        console.log(`Testing: ${url}`);
        try {
          const result = await readTag({lang: testLang, id});
          console.log(`Result for ${id}:`, result);
        } catch (e) {
          console.log(`Error for ${id}:`, e.message);
        }
      }
    };
    console.log('Debug function available: window.debugCoverage()');
    
    build().catch(e=>{ console.error(e); alert('Failed to build coverage: '+e.message); });
  </script>
</body>
</html>

