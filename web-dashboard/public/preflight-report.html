<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>Languages Preflight Readiness Report</title>
	<link rel="icon" type="image/svg+xml" href="./favicon.svg">
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
	<link rel="stylesheet" href="./styles.css">
	<style>
		body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 20px; color: #222; }
		h1 { font-size: 20px; margin-bottom: 16px; }
		.table { width: 100%; border-collapse: collapse; }
		.table th, .table td { border: 1px solid #e5e7eb; padding: 8px 10px; font-size: 13px; text-align: left; }
		.table thead th { background: #f8fafc; position: sticky; top: 0; }
		.badge { display: inline-block; padding: 2px 6px; border-radius: 10px; font-size: 12px; font-weight: 600; }
		.ok { background: #e7f7ec; color: #1f7a37; }
		.warn { background: #fff7e6; color: #8a6d1f; }
		.err { background: #fde7ea; color: #842029; }
		.small { color: #374151; font-size: 12px; font-weight: 500; }
		.code { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', monospace; background: #f3f4f6; padding: 1px 4px; border-radius: 4px; }
		.footer { margin-top: 16px; font-size: 12px; color: #6b7280; }
		.section { margin-top: 20px; padding-top: 8px; border-top: 1px solid #e5e7eb; }
		.link { color: #0d6efd; cursor: pointer; text-decoration: underline; }
	</style>
</head>
<body>
	<h1><i class="fas fa-clipboard-list"></i> Languages Preflight Readiness Report</h1>
	<p class="small">Environment: <span id="envLabel" class="code">dev</span></p>
	<table class="table" id="reportTable" aria-label="Languages Preflight Readiness table">
		<thead>
			<tr>
				<th>Language</th>
				<th>Code</th>
				<th>From Crowdin</th>
				<th>Surveys</th>
				<th>Dashboard</th>
				<th>Audio</th>
			</tr>
		</thead>
		<tbody></tbody>
	</table>

	<div class="section" id="visualAudit">
		<h2 style="font-size:16px; margin:0 0 8px 0;">Visual Assets Audit</h2>
		<p class="small">Bucket: <span id="visualBucket" class="code"></span> · Prefix: <span id="visualPrefix" class="code">visual/</span></p>
		<p id="visualSummary" class="small">Loading…</p>
		<p class="small"><span id="visualDetails" class="link" style="display:none; margin-right:12px;">Show missing PNG → WEBP list</span><button id="visualFixBtn" style="display:none; padding:6px 10px; border:1px solid #d1d5db; border-radius:6px; background:#0d6efd; color:white; cursor:pointer;">Fix It</button></p>
	</div>
	<div class="footer">
		Color legend: <span class="badge ok">100%</span> <span class="badge warn">&gt; 0%</span> <span class="badge err">0%</span>
		<div class="small" style="margin-top:6px;">
			- <span class="badge ok">yes</span>: exact locale file exists in levante-dashboard (e.g., de-CH)
			- <span class="badge warn">base</span>: only base language file exists (e.g., de)
			- <span class="badge err">missing</span>: neither exact nor base locale file exists
			- Surveys %: percentage of survey JSONs that include the locale (or base for fallback; English counts implicit defaults)
			- From Crowdin: coverage of Item Bank CSV translations
		</div>
	</div>

	<script>
	(async function() {
		const urlParams = new URLSearchParams(window.location.search);
		const env = (urlParams.get('env') || 'dev').toLowerCase();
		document.getElementById('envLabel').textContent = env;

		// Load dashboard config and CSV data
		const cfg = await fetch('./config.js').then(r => r.text()).then(js => { const m = {}; const f = new Function('module', js + '; return module.exports;'); return f(m); }).catch(() => ({}));
		const CONFIG = (cfg && cfg.CONFIG) || (window.CONFIG || {});
		let csvText = '';
		// Prefer remote CSV first
		const primaryUrl = (CONFIG && CONFIG.dataSources && CONFIG.dataSources.remoteCSV) || 'https://raw.githubusercontent.com/levante-framework/levante_translations/l10n_pending/item-bank-translations.csv';
		try {
			const resRemote = await fetch(primaryUrl, { cache: 'no-cache' });
			if (resRemote.ok) csvText = await resRemote.text();
		} catch (e) {}
		// Fallback to local complete CSV
		if (!csvText) {
			try {
				const res = await fetch('./translation_text/complete_translations.csv', { cache: 'no-cache' });
				if (res.ok) csvText = await res.text();
			} catch (e) {}
		}

		function parseCSVWithEmbeddedNewlines(csvText) {
			const rows = []; let currentRow = []; let currentField = ''; let inQuotes = false; let i = 0;
			while (i < csvText.length) {
				const ch = csvText[i]; const next = i + 1 < csvText.length ? csvText[i + 1] : '';
				if (ch === '"') { if (inQuotes && next === '"') { currentField += '"'; i += 2; } else { inQuotes = !inQuotes; i++; } }
				else if (ch === ',' && !inQuotes) { currentRow.push(currentField.trim()); currentField = ''; i++; }
				else if ((ch === '\n' || ch === '\r') && !inQuotes) { if (currentField.trim() || currentRow.length > 0) { currentRow.push(currentField.trim()); if (currentRow.some(f => f.length > 0)) rows.push(currentRow); currentRow = []; currentField = ''; } if (ch === '\r' && next === '\n') i += 2; else i++; }
				else { currentField += ch; i++; }
			}
			if (currentField.trim() || currentRow.length > 0) { currentRow.push(currentField.trim()); if (currentRow.some(f => f.length > 0)) rows.push(currentRow); }
			return rows.filter(r => r.length > 0 && r.some(f => f && f.trim().length > 0));
		}
		function csvToObjects(csvText) {
			const rows = parseCSVWithEmbeddedNewlines(csvText); if (rows.length === 0) return [];
			const headers = rows[0]; const data = [];
			for (let i = 1; i < rows.length; i++) { const row = rows[i]; if (row.length < headers.length) continue; const obj = {}; headers.forEach((h, idx) => obj[h] = (row[idx] || '').trim()); data.push(obj); }
			return data;
		}
		const items = csvToObjects(csvText);
		// Discover languages from header
		const headers = (parseCSVWithEmbeddedNewlines(csvText)[0] || []);
		const knownNonLang = new Set(['item_id','identifier','labels','task','context','en']);
		const languageCodes = headers.filter(h => !knownNonLang.has(h) && /^[a-z]{2}(-[A-Z]{2})?$/.test(h));
		if (!languageCodes.includes('en')) languageCodes.unshift('en');

		function toBase(lang) { return lang.includes('-') ? lang.split('-')[0] : lang; }
		function pct(n, d) { return d ? Math.round((n / d) * 10000)/100 : 0; }
		function badge(n, d) {
			const p = pct(n, d);
			const cls = p === 100 ? 'ok' : (p > 0 ? 'warn' : 'err');
			return `<span class="badge ${cls}">${p}%</span>`;
		}
		function capitalize(s) { return (s && s.length) ? s.charAt(0).toUpperCase() + s.slice(1) : s; }
		function languageDisplayName(code) {
			// Prefer CONFIG mapping, but append region if code includes one and name doesn't already include it
			const match = Object.entries(CONFIG.languages || {}).find(([name, cfg]) => cfg.lang_code === code);
			const parts = code.split('-');
			const langPart = parts[0];
			const regionPart = parts[1];
			if (match) {
				const [fallbackName, cfg] = match;
				const baseName = cfg.display_name || fallbackName;
				if (regionPart) {
					if (baseName.includes('(')) return baseName; // already includes region
					try {
						const regionNames = new Intl.DisplayNames(['en'], { type: 'region' });
						const regionName = regionNames.of(regionPart.toUpperCase()) || regionPart.toUpperCase();
						return `${baseName} (${regionName})`;
					} catch (e) {
						return `${baseName} (${regionPart.toUpperCase()})`;
					}
				}
				return baseName;
			}
			// Fallback via Intl
			try {
				const langNames = new Intl.DisplayNames(['en'], { type: 'language' });
				const languageName = langNames.of(langPart) || langPart;
				if (regionPart) {
					const regionNames = new Intl.DisplayNames(['en'], { type: 'region' });
					const regionName = regionNames.of(regionPart.toUpperCase()) || regionPart.toUpperCase();
					return `${capitalize(languageName)} (${regionName})`;
				}
				return capitalize(languageName);
			} catch (e) {
				return regionPart ? `${langPart} (${regionPart.toUpperCase()})` : langPart;
			}
		}

		// ItemBank readiness per language
		function itembankStats(lang) {
			const exact = items.filter(r => (r[lang] || '').trim().length > 0).length;
			const base = toBase(lang);
			const withBase = items.filter(r => ((r[lang] || r[base] || '').trim().length > 0)).length;
			return { total: items.length, exact, withBase };
		}

		// Dashboard translations: fetch from levante-dashboard repo JSONs (componentTranslations)
		async function fetchDashboardJsonPath(code) {
			const lower = code.toLowerCase();
			const parts = lower.split('-');
			if (parts.length === 2) {
				return `https://raw.githubusercontent.com/levante-framework/levante-dashboard/main/src/translations/${parts[0]}/${parts[1]}/${lower}-componentTranslations.json`;
			}
			return `https://raw.githubusercontent.com/levante-framework/levante-dashboard/main/src/translations/${lower}/${lower}-componentTranslations.json`;
		}
		async function fetchDashboardJson(code) {
			const url = await fetchDashboardJsonPath(code);
			try { const r = await fetch(url, { cache: 'no-cache' }); if (r.ok) return await r.json(); } catch (e) {}
			return null;
		}
		function countLeafStrings(obj) {
			if (!obj || typeof obj !== 'object') return 0;
			let count = 0;
			for (const k of Object.keys(obj)) {
				const v = obj[k];
				if (v && typeof v === 'object') count += countLeafStrings(v);
				else if (typeof v === 'string') count += 1;
			}
			return count;
		}
		async function dashboardStats(lang) {
			const exactUrl = await fetchDashboardJsonPath(lang);
			let exactMatch = false;
			let baseMatch = false;
			try { const r = await fetch(exactUrl, { method: 'HEAD', cache: 'no-cache' }); if (r.ok) exactMatch = true; } catch (e) {}
			if (!exactMatch && lang.includes('-')) {
				const baseUrl = await fetchDashboardJsonPath(toBase(lang));
				try { const r2 = await fetch(baseUrl, { method: 'HEAD', cache: 'no-cache' }); if (r2.ok) baseMatch = true; } catch (e) {}
			}
			return { exactMatch, baseMatch };
		}

		// Survey translations: list JSONs from levante-dashboard-dev and check for keys
		async function surveyStats(lang) {
			try {
				// Static list based on known files in bucket (as exposed in repo), adjust if endpoint exists later
				const candidates = ['child_survey.json','parent_survey_child.json','parent_survey_family.json','teacher_survey_classroom.json','teacher_survey_general.json'];
				const base = toBase(lang);
				let checked = 0, exact = 0, withBase = 0;
				const details = [];
				for (const name of candidates) {
					try {
						const url = `https://storage.googleapis.com/levante-dashboard-dev/${name}`;
						const res = await fetch(url, { cache: 'no-cache' });
						if (!res.ok) continue;
						const txt = await res.text();
						checked++;
						let hasExact = txt.includes(`"${lang}"`) || txt.includes(`'${lang}'`);
						let hasBase = !hasExact && (txt.includes(`"${base}"`) || txt.includes(`'${base}'`));
						// Treat implicit English as coverage when no explicit locale keys are present
						// - exact for 'en'
						// - base for any 'en-*' variant
						if (!hasExact && !hasBase && base === 'en') {
							if (lang === 'en') { hasExact = true; } else { hasBase = true; }
						}
						if (hasExact) exact++; if (hasBase) withBase++;
						details.push({ file: name, hasExact, hasBase });
					} catch {}
				}
				return { checked, exact, withBase, details };
			} catch { return { checked: 0, exact: 0, withBase: 0, details: [] }; }
		}

		// Audio presence: ping api/read-tags in strict mode for a subset, but here aggregate presence by listing top-level prefixes from bucket via API list=1
		async function audioStats(lang) {
			try {
				const res = await fetch('/api/read-tags?list=1', { cache: 'no-cache' });
				if (!res.ok) return { present: false };
				const data = await res.json();
				const present = Array.isArray(data.languages) && data.languages.includes(lang);
				return { present };
			} catch { return { present: false }; }
		}

		// Build table rows with bounded concurrency
		const tbody = document.querySelector('#reportTable tbody');
		for (const lang of languageCodes) {
			const ib = itembankStats(lang);
			const ds = await dashboardStats(lang);
			const [sv, au] = await Promise.all([surveyStats(lang), audioStats(lang)]);
			const tr = document.createElement('tr');
			tr.innerHTML = `
				<td>${languageDisplayName(lang)}</td>
				<td><span class="code">${lang}</span></td>
				<td>${badge(ib.exact, ib.total)} <span class="small">(${ib.exact}/${ib.total})</span></td>
				<td class="svcell">${sv.checked === 0 ? '<span class="badge warn">n/a</span>' : badge(sv.exact + sv.withBase, sv.checked)} <span class="small">(${sv.exact}/${sv.checked}, base ${sv.withBase})</span></td>
				<td>${ds.exactMatch ? '<span class="badge ok">yes</span>' : (ds.baseMatch ? '<span class="badge warn">base</span>' : '<span class="badge err">missing</span>')}</td>
				<td>${au.present ? '<span class="badge ok">present</span>' : '<span class="badge err">missing</span>'}</td>
			`;
			const svCell = tr.querySelector('.svcell');
			if (svCell) {
				const infoBtn = document.createElement('button');
				infoBtn.title = 'Show survey details';
				infoBtn.setAttribute('aria-label', 'Show survey details');
				infoBtn.style.border = 'none';
				infoBtn.style.background = 'none';
				infoBtn.style.cursor = 'pointer';
				infoBtn.style.color = '#0d6efd';
				infoBtn.textContent = 'ℹ️';
				const details = sv.details || [];
				infoBtn.addEventListener('click', () => {
					const ok = details.filter(x => x.hasExact || x.hasBase).map(x => x.file);
					const missing = details.filter(x => !x.hasExact && !x.hasBase).map(x => x.file);
					alert('Translated (or base):\n- ' + (ok.join('\n- ') || 'None') + '\n\nMissing:\n- ' + (missing.join('\n- ') || 'None'));
				});
				svCell.appendChild(infoBtn);
			}
			tbody.appendChild(tr);
		}

		// Visual assets audit + Fix It
		async function refreshVisualAudit() {
			try {
				const res = await fetch(`/api/visual-audit?env=${encodeURIComponent(env)}&prefix=visual/`, { cache: 'no-cache' });
				if (!res.ok) { document.getElementById('visualSummary').textContent = 'Visual audit unavailable (API error)'; return; }
				const data = await res.json();
				document.getElementById('visualBucket').textContent = data.bucket || '';
				const missing = Array.isArray(data.missing) ? data.missing : [];
				const pngCount = data.pngCount || 0;
				const webpCount = data.webpCount || 0;
				const missingCount = data.missingCount || missing.length;
				const summary = document.getElementById('visualSummary');
				summary.innerHTML = `PNGs: <span class="code">${pngCount}</span> · WEBPs: <span class="code">${webpCount}</span> · Missing WEBP: <span class="badge ${missingCount===0?'ok':'err'}">${missingCount}</span>`;
				const detailsLink = document.getElementById('visualDetails');
				const fixBtn = document.getElementById('visualFixBtn');
				if (missingCount > 0) {
					detailsLink.style.display = '';
					fixBtn.style.display = '';
					detailsLink.onclick = () => { alert('PNGs without WEBP (first 200 shown):\n- ' + missing.slice(0,200).join('\n- ')); };
				} else {
					detailsLink.style.display = 'none';
					fixBtn.style.display = 'none';
				}
			} catch (e) {
				document.getElementById('visualSummary').textContent = 'Visual audit unavailable';
			}
		}

		await refreshVisualAudit();

		const fixBtn = document.getElementById('visualFixBtn');
		if (fixBtn) {
			fixBtn.addEventListener('click', async () => {
				const prev = fixBtn.textContent;
				fixBtn.disabled = true; fixBtn.textContent = 'Fixing…';
				try {
					const res = await fetch(`/api/visual-fix?env=${encodeURIComponent(env)}&prefix=visual/&limit=200`, { method: 'POST' });
					if (res.ok) {
						const data = await res.json();
						const top = Array.isArray(data.topReasons) && data.topReasons.length ? ('\nTop reasons: ' + data.topReasons.map(r=>`${r.reason} (${r.count})`).join(', ')) : '';
						alert(`WEBP created: ${data.created}\nFailed: ${data.failed}\nRemaining (est): ${data.remainingEstimate}${top}`);
						await refreshVisualAudit();
					} else {
						alert('Fix failed: API error');
					}
				} catch (e) {
					alert('Fix failed: ' + (e && e.message ? e.message : 'unknown error'));
				} finally {
					fixBtn.disabled = false; fixBtn.textContent = prev;
				}
			});
		}
	})();
	</script>
</body>
</html>
